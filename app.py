import cv2
import mediapipe as mp
from cvzone.HandTrackingModule import HandDetector
from flask import Flask, jsonify, request, Response, render_template, url_for
import numpy as np

import firebase_admin
from firebase_admin import credentials, db

def transformImage(img_path):
    image = cv2.imread(img_path)
    #image = cv2.resize(image,(240,240))
    print("width: {} pixels".format(image.shape[1]))
    print("height: {} pixels".format(image.shape[0]))
    print("channels: {}".format(image.shape[2]))
    dim=(500,590)
    image=cv2.resize(image, dim)

    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY, 0.7)

    (T, thresh) = cv2.threshold(gray, 155, 255, cv2.THRESH_BINARY)

    (T, threshInv) = cv2.threshold(gray, 155, 255, cv2.THRESH_BINARY_INV)

    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (10, 5))
    closed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)

    closed = cv2.erode(closed, None, iterations = 19)
    closed = cv2.dilate(closed, None, iterations = 17)

    ret,mask = cv2.threshold(closed, 155, 255, cv2.THRESH_BINARY) 
    #apply AND operation on image and mask generated by thrresholding
    final = cv2.bitwise_and(image,image,mask = mask) 

    def auto_canny(image, sigma=0.33):
        # compute the median of the single channel pixel intensities
        v = np.median(image)
        # apply automatic Canny edge detection using the computed median
        lower = int(max(0, (1.0 - sigma) * v))
        upper = int(min(255, (1.0 + sigma) * v))
        edged = cv2.Canny(image, lower, upper)
        
        # return the edged image
        return edged

    canny = auto_canny(closed)
    (cnts, _) = cv2.findContours(canny.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    cv2.drawContours(image, cnts, -1, (0, 0, 255), 2)
    return image


app = Flask(__name__)
camera = cv2.VideoCapture(0)
camera.set(3, 1280)
camera.set(4, 1280)
image = transformImage('C:/Users/adity/OneDrive/Documents/PennApps/static/brainTumorImg.png')

detector = HandDetector(detectionCon=0.8)
startDist = None
scale = 0
cy = 500
cx = 500


cred = credentials.Certificate('C:/Users/adity/Downloads/healthapp-ec047-firebase-adminsdk-k270h-b85c861e35.json')
firebase_admin.initialize_app(cred, {
    'databaseURL': 'https://healthapp-ec047-default-rtdb.firebaseio.com'
})


def gen_frames():
    while True:
        success, frame = camera.read()
        hands, frame = detector.findHands(frame)
        #hands = detector.findHand(img, draw = False)

        img1 = image

        if len(hands) == 2:
            hand1 = hands[0]
            lmList1 = hands[0]["lmList"] # Lost of 21 Landmark points
            bbox1 = hand1["bbox"] # Bounding Box info
            centerPoint1 = hand1["center"]
            handType1 = hand1["type"]
            
            fingers1 = detector.fingersUp(hand1)

            hand2 = hands[1]
            lmList2 = hands[1]["lmList"] # Lost of 21 Landmark points
            bbox2 = hand2["bbox"] # Bounding Box info
            centerPoint2 = hand2["center"]
            handType2 = hand2["type"]

            fingers2 = detector.fingersUp(hand2)
                
            #print(handType1, handType2)
            #print(fingers1, fingers2)
            length, info, frame = detector.findDistance(centerPoint1, centerPoint2, frame)

            if detector.fingersUp(hand1) == [1,1,0,0,0] and detector.fingersUp(hand2) == [1,1,0,0,0]:
                #print("Zoom Gesture")
                    
                if startDist is None:
                    length, info, frame = detector.findDistance(centerPoint1, centerPoint2, frame)
                    #print(length)
                    startDist = length

                length, info, frame = detector.findDistance(centerPoint1, centerPoint2, frame)
                #length, info, img = detector.findDistance(lmList1[8], lmList2[8], img)
                scale = int((length - startDist)//2)
                cx, cy = info[4:] 
                print(scale)
        else:
            startDist = None
        
        try:
            h1, w1, _= img1.shape
            
            newH, newW = ((h1+scale)//2)*2, ((w1+scale)//2)*2
            
            img1 = cv2.resize(img1, (newW, newH)) 

            frame[cy-newH//2:cy+newH//2, cx-newW//2:cx+newW//2] = img1 
            #img[0:500, 0:402] = img1
        except:
            pass

        ret, buffer = cv2.imencode('.jpg', frame)
        frame = buffer.tobytes()
        yield (b'--frame\r\n'
               b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')


@app.route('/')
def index():
    return render_template('index.html')

@app.route('/video_feed')
def video_feed():
    return Response(gen_frames(), mimetype='multipart/x-mixed-replace; boundary=frame')

@app.route('/api/data')
def get_data():
    ref = db.reference('/motionData/accelerationAlert')
    data = ref.get()
    print('fetched', data)
    return jsonify(data)


if __name__ == '__main__':
    app.run(debug=True)


'''import io
import json

from torchvision import models
import torchvision.transforms as transforms
from PIL import Image
from flask import Flask, jsonify, request, Response, render_template

import os
import cv2
import zipfile
from fastai.vision.all import *
import numpy as np
import glob
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import ImageGrid

import warnings
warnings.filterwarnings("ignore")


import os  
import shutil
from pathlib import Path
import random


def transformImage(img_path):
    image = cv2.imread(img_path)
    #image = cv2.resize(image,(240,240))
    print("width: {} pixels".format(image.shape[1]))
    print("height: {} pixels".format(image.shape[0]))
    print("channels: {}".format(image.shape[2]))
    dim=(500,590)
    image=cv2.resize(image, dim)

    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY, 0.7)

    (T, thresh) = cv2.threshold(gray, 155, 255, cv2.THRESH_BINARY)

    (T, threshInv) = cv2.threshold(gray, 155, 255, cv2.THRESH_BINARY_INV)

    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (10, 5))
    closed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)

    closed = cv2.erode(closed, None, iterations = 19)
    closed = cv2.dilate(closed, None, iterations = 17)

    ret,mask = cv2.threshold(closed, 155, 255, cv2.THRESH_BINARY) 
    #apply AND operation on image and mask generated by thrresholding
    final = cv2.bitwise_and(image,image,mask = mask) 

    def auto_canny(image, sigma=0.33):
        # compute the median of the single channel pixel intensities
        v = np.median(image)
        # apply automatic Canny edge detection using the computed median
        lower = int(max(0, (1.0 - sigma) * v))
        upper = int(min(255, (1.0 + sigma) * v))
        edged = cv2.Canny(image, lower, upper)
        
        # return the edged image
        return edged

    canny = auto_canny(closed)
    (cnts, _) = cv2.findContours(canny.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    cv2.drawContours(image, cnts, -1, (0, 0, 255), 2)
    return image

app = Flask(__name__)
camera = cv2.VideoCapture(1)
image = transformImage('C:/Users/adity/OneDrive/Documents/PennApps/yes/Y14.jpg')

def gen_frames():
    while True:
        success, frame = camera.read()
        if not success:
            break
        else:
            # Resize the image to match the frame dimensions
            resized_image = cv2.resize(image, (frame.shape[1], frame.shape[0]))
            frame = cv2.addWeighted(frame, 1, resized_image, 0.5, 0)
            ret, buffer = cv2.imencode('.jpg', frame)
            frame = buffer.tobytes()
            yield (b'--frame\r\n'
                   b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n')

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/video_feed')
def video_feed():
    return Response(gen_frames(), mimetype='multipart/x-mixed-replace; boundary=frame')

if __name__ == '__main__':
    app.run(debug=True)'''
